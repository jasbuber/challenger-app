package repositories;

import domain.*;
import play.db.DB;
import play.db.jpa.JPA;

import javax.persistence.Query;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.List;

public class ChallengesRepository {

    public Challenge createChallenge(User user, String challengeName, ChallengeCategory category, String videoId, Boolean visibility) {
        Challenge challenge = new Challenge(user, challengeName, category, videoId, visibility);
        JPA.em().persist(challenge);
        return challenge;
    }

    public boolean isChallengeWithGivenNameExistsForUser(String challengeName, String creatorUsername) {
        Query challengesWithNameOfCreatorNrQuery = JPA.em().createQuery("SELECT count(c) " +
                                                        "FROM Challenge c " +
                                                        "WHERE LOWER(c.challengeName) = LOWER(:challengeName) " +
                                                        "AND LOWER(c.creator.username) = LOWER(:creatorUsername)");
        challengesWithNameOfCreatorNrQuery.setParameter("challengeName", challengeName);
        challengesWithNameOfCreatorNrQuery.setParameter("creatorUsername", creatorUsername);
        Long challengesWithNameOfCreatorNr = (Long) challengesWithNameOfCreatorNrQuery.getSingleResult();
        return challengesWithNameOfCreatorNr > 0;
    }

    public ChallengeParticipation createChallengeParticipation(Challenge challenge, User user) {
        ChallengeParticipation challengeParticipation = new ChallengeParticipation(challenge, user);
        JPA.em().persist(challengeParticipation);
        return challengeParticipation;
    }

    //Method should be handled based on database and concurrency integrity
    public boolean deleteChallengeParticipation(Challenge challenge, User user) {
        Query challengeParticipationQuery = JPA.em().createQuery("SELECT c FROM ChallengeParticipation c " +
                                                                 "WHERE LOWER(c.participator.username) = LOWER(:username)" +
                                                                 "AND LOWER(c.challenge.challengeName) = LOWER(:challengeName)");
        challengeParticipationQuery.setParameter("username", user.getUsername());
        challengeParticipationQuery.setParameter("challengeName", challenge.getChallengeName());
        ChallengeParticipation challengeParticipation = (ChallengeParticipation) challengeParticipationQuery.getSingleResult();
        JPA.em().remove(challengeParticipation);
        return true;
    }

    //todo check sql generated by hibernate -> if there is not unnecessary join with Challenge added
    public boolean isUserParticipatingInChallenge(Challenge challenge, String participatorUsername) {
        Query usernameUsersParticipatingNrQuery = JPA.em().createQuery("SELECT count(p) " +
                                                                    "FROM ChallengeParticipation p " +
                                                                    "WHERE p.challenge = :challenge " +
                                                                    "AND LOWER(p.participator.username) = LOWER(:participatorUsername)");
        usernameUsersParticipatingNrQuery.setParameter("challenge", challenge);
        usernameUsersParticipatingNrQuery.setParameter("participatorUsername", participatorUsername);
        Long usernameUsersParticipatingNr = (Long) usernameUsersParticipatingNrQuery.getSingleResult();
        return usernameUsersParticipatingNr > 0;
    }

    public ChallengeResponse addChallengeResponse(ChallengeParticipation challengeParticipation) {
        ChallengeResponse challengeResponse = new ChallengeResponse(challengeParticipation);
        JPA.em().persist(challengeResponse);
        return challengeResponse;
    }

    public ChallengeParticipation getChallengeParticipation(Challenge challenge, String participatorUsername) {
        return new ChallengeParticipation(challenge, new User(participatorUsername));
    }

    public boolean isNotScoredChallengeResponseExistsFor(ChallengeParticipation challengeParticipation) {
        return false;
    }

    public Challenge getChallenge(long id){ return JPA.em().find(Challenge.class, id); }

    public List<Challenge> findChallenges(ChallengeFilter challengeFilter){
        return challengeFilter.getQuery().getResultList();
    }

    public ChallengeResponse updateChallengeResponse(ChallengeResponse challengeResponse) {
        return JPA.em().merge(challengeResponse);
    }

    public Long countCreatedChallengesForUser(String username){
        Query challengesCreatedByUserQuery = JPA.em().createQuery("SELECT count(c) FROM Challenge c " +
                "WHERE LOWER(c.creator) = LOWER(:username)");
        challengesCreatedByUserQuery.setParameter("username", username);
        return (Long) challengesCreatedByUserQuery.getSingleResult();
    }

    public Long countCompletedChallenges(String participatorUsername) {
        Query completedChallengesQuery = JPA.em().createQuery("SELECT count(r) " +
                "FROM ChallengeResponse r " +
                "INNER JOIN r.challengeParticipation p " +
                "WHERE r.isAccepted = 'Y'" +
                "AND LOWER(p.participator.username) = LOWER(:participatorUsername)");
        completedChallengesQuery.setParameter("participatorUsername", participatorUsername);
        return (Long) completedChallengesQuery.getSingleResult();
    }

    public List getChallengesWithParticipantsNrForUser(String creatorUsername) {
        Query completedChallengesQuery = JPA.em().createQuery("SELECT c.challengeName as name, c.creationDate, count(p), c.id " +
                "FROM ChallengeParticipation p " +
                "RIGHT OUTER JOIN p.challenge c " +
                "WHERE c.active = true " +
                "AND LOWER(c.creator.username) = LOWER(:creatorUsername) " +
                "GROUP BY c.challengeName");
        completedChallengesQuery.setParameter("creatorUsername", creatorUsername);
        return completedChallengesQuery.getResultList();
    }

    public Challenge closeChallenge(long id){
        Challenge challenge = getChallenge(id);
        if( challenge.isActive() ){
            challenge.setInactive();
            return JPA.em().merge(challenge);
        }
        return challenge;
    }

    public List<ChallengeResponse> getResponsesForChallenge(long challengeId) {
        Query completedChallengesQuery = JPA.em().createQuery("SELECT r " +
                "FROM ChallengeResponse r " +
                "WHERE LOWER(r.challengeParticipation.challenge.id) = LOWER(:challengeId)");
        completedChallengesQuery.setParameter("challengeId", challengeId);
        return completedChallengesQuery.getResultList();
    }

    public ChallengeResponse getChallengeResponse(long id){ return JPA.em().find(ChallengeResponse.class, id); }
}
