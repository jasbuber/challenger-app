package repositories;

import domain.*;
import play.db.DB;
import play.db.jpa.JPA;

import javax.persistence.Query;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.List;

public class ChallengesRepository {

    //TODO challenge creation should be delegated to service, respository should not be responsible for creating object. Only for storing it.
    public Challenge createChallenge(User user, String challengeName, ChallengeCategory category, String videoId, Boolean visibility) {
        Challenge challenge = new Challenge(user, challengeName, category, videoId, visibility);
        JPA.em().persist(challenge);
        return challenge;
    }

    public boolean isChallengeWithGivenNameExistsForUser(String challengeName, String creatorUsername) {
        Query challengesWithNameOfCreatorNrQuery = JPA.em().createQuery("SELECT count(c) " +
                                                        "FROM Challenge c " +
                                                        "WHERE LOWER(c.challengeName) = LOWER(:challengeName) " +
                                                        "AND LOWER(c.creator.username) = LOWER(:creatorUsername)");
        challengesWithNameOfCreatorNrQuery.setParameter("challengeName", challengeName);
        challengesWithNameOfCreatorNrQuery.setParameter("creatorUsername", creatorUsername);
        Long challengesWithNameOfCreatorNr = (Long) challengesWithNameOfCreatorNrQuery.getSingleResult();
        return challengesWithNameOfCreatorNr > 0;
    }

    //TODO challengeParticipation creation should be delegated to service, respository should not be responsible for creating object. Only for storing it.
    public ChallengeParticipation createChallengeParticipation(Challenge challenge, User user) {
        ChallengeParticipation challengeParticipation = new ChallengeParticipation(challenge, user);
        JPA.em().persist(challengeParticipation);
        return challengeParticipation;
    }

    //Method should be handled based on database and concurrency integrity
    public boolean deleteChallengeParticipation(Challenge challenge, User user) {
        Query challengeParticipationQuery = JPA.em().createQuery("SELECT c FROM ChallengeParticipation c " +
                                                                 "WHERE LOWER(c.participator.username) = LOWER(:username)" +
                                                                 "AND LOWER(c.challenge.challengeName) = LOWER(:challengeName)");
        challengeParticipationQuery.setParameter("username", user.getUsername());
        challengeParticipationQuery.setParameter("challengeName", challenge.getChallengeName());
        ChallengeParticipation challengeParticipation = (ChallengeParticipation) challengeParticipationQuery.getSingleResult();
        JPA.em().remove(challengeParticipation);
        return true;
    }

    //todo check sql generated by hibernate -> if there is not unnecessary join with Challenge added
    public boolean isUserParticipatingInChallenge(Challenge challenge, String participatorUsername) {
        Query usernameUsersParticipatingNrQuery = JPA.em().createQuery("SELECT count(p) " +
                                                                    "FROM ChallengeParticipation p " +
                                                                    "WHERE p.challenge = :challenge " +
                                                                    "AND LOWER(p.participator.username) = LOWER(:participatorUsername)");
        usernameUsersParticipatingNrQuery.setParameter("challenge", challenge);
        usernameUsersParticipatingNrQuery.setParameter("participatorUsername", participatorUsername);
        Long usernameUsersParticipatingNr = (Long) usernameUsersParticipatingNrQuery.getSingleResult();
        return usernameUsersParticipatingNr > 0;
    }

    public ChallengeResponse addChallengeResponse(ChallengeResponse challengeResponse) {
        JPA.em().persist(challengeResponse);
        return challengeResponse;
    }

    /**
     * THIS METHOD THROWS EXCEPTION WHEN NO CHALLENGE PARTICIPATION EXISTS FOR GIVEN ARGUMENTS.
     *
     * Must be used only after succeeded test for user's participation in challenge.
     *
     * No exception is thrown if there is more than one challenge participation for user. The first found result will be returned.
     * However this is invalid state of the system and is logged with error level.
     *
     * @param challenge challenge to get one of participations for
     * @param participatorUsername username of the participator in challenge
     * @return challengeParticipation for given challenge of given participator
     * @throws java.lang.IllegalStateException if there is no challengeParticipation for given challenge of given participator
     */
    public ChallengeParticipation getChallengeParticipation(Challenge challenge, String participatorUsername) {
        Query getChallengeParticipationQuery = JPA.em().createQuery("SELECT p " +
                                                                    "FROM ChallengeParticipation p " +
                                                                    "WHERE p.challenge = :challenge " +
                                                                    "AND LOWER(p.participator.username) = LOWER(:participatorUsername)");
        getChallengeParticipationQuery.setParameter("challenge", challenge);
        getChallengeParticipationQuery.setParameter("participatorUsername", participatorUsername);

        List<ChallengeParticipation> challengeParticipations = getChallengeParticipationQuery.getResultList();

        assertThatChallengeParticipationIsFound(challenge, participatorUsername, challengeParticipations);

        if(challengeParticipations.size() > 1) {
            //TODO when logger will be added then invalid system state should be logged with error level
        }

        return challengeParticipations.get(0);
    }

    private void assertThatChallengeParticipationIsFound(Challenge challenge, String participatorUsername, List<ChallengeParticipation> challengeParticipations) {
        if(challengeParticipations.isEmpty()) {
            throw new IllegalStateException("Participator: " + participatorUsername + " is not participating in challenge " + challenge.getChallengeName());
        }
    }

    //TODO must be implemented
    public boolean isNotScoredChallengeResponseExistsFor(ChallengeParticipation challengeParticipation) {
        return false;
    }

    public Challenge getChallenge(long id){ return JPA.em().find(Challenge.class, id); }

    public List<Challenge> findChallenges(ChallengeFilter challengeFilter){
        return challengeFilter.getQuery().getResultList();
    }

    public ChallengeResponse updateChallengeResponse(ChallengeResponse challengeResponse) {
        return JPA.em().merge(challengeResponse);
    }

    public List<User> getAllParticipatorsOf(Challenge challenge) {
        Query participators = JPA.em().createQuery("SELECT p.participator " +
                                                  "FROM ChallengeParticipation p " +
                                                  "WHERE p.challenge = :challenge");
        participators.setParameter("challenge", challenge);
        return participators.getResultList();
    }

    public Long countCreatedChallengesForUser(String username){
        Query challengesCreatedByUserQuery = JPA.em().createQuery("SELECT count(c) FROM Challenge c " +
                "WHERE LOWER(c.creator) = LOWER(:username)");
        challengesCreatedByUserQuery.setParameter("username", username);
        return (Long) challengesCreatedByUserQuery.getSingleResult();
    }

    public Long countCompletedChallenges(String participatorUsername) {
        Query completedChallengesQuery = JPA.em().createQuery("SELECT count(r) " +
                "FROM ChallengeResponse r " +
                "INNER JOIN r.challengeParticipation p " +
                "WHERE r.isAccepted = 'Y'" +
                "AND LOWER(p.participator.username) = LOWER(:participatorUsername)");
        completedChallengesQuery.setParameter("participatorUsername", participatorUsername);
        return (Long) completedChallengesQuery.getSingleResult();
    }
}
